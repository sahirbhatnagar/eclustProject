---
title: 
output:
  html_document:
    fig_height: 8
    fig_width: 11
    code_folding: hide
    toc: false
    toc_float: false
---


```{r setup, echo=FALSE,warning=FALSE,message=FALSE,cache=FALSE, results='hide'}
options(width=60, digits=2)
#set.seed(45)
library(knitr)
options(decorate.contr.Treatment = "")
opts_chunk$set(echo = FALSE, tidy = TRUE, cache = FALSE, warning = FALSE, 
               message = FALSE)
opts_template$set(
    fig.large = list(fig.width = 7, fig.height = 5, fig.align = 'center', 
                     fig.pos = 'H'),
    fig.small = list(fig.width = 6, fig.height = 4, fig.align = 'center', 
                     fig.pos = 'H'),
    fig.full = list(fig.width = 11, fig.height = 8, fig.align = 'center', 
                    fig.pos = 'H')
)
# for captions to be evaluated after R objects are available 
opts_knit$set(eval.after = 'fig.cap') 
knitr::read_chunk("~/git_repositories/eclust/analysis.R")
#knitr::read_chunk(paste(Sys.getenv("HOME"), "eclust/bin/simulation/simDataWGCNA.R", sep = "/"))
```

```{r functions-packages, results='hide', message=FALSE, warning=FALSE}
source("~/git_repositories/eclust/functions.R")
source("~/git_repositories/eclust/packages.R")
```

```{r data, results='hide', eval=TRUE, message=FALSE}

```

```{r correlation-data-example}
parametersDf <- expand.grid(rho = c(0.2,0.50,0.90),
                            p = c(500, 1000),
                            SNR = c(1),
                            n = c(100,200,400), # this is the total train + test sample size
                            nActive = c(10, 50, 100), # must be even because its being split among two modules
                            #n0 = 200,
                            cluster_distance = c("corr"),
                            Ecluster_distance = c("diffcorr","fisherScore"),
                            rhoOther = 0.6,
                            betaMean = 4,
                            betaE = 5,
                            alphaMean = 2,
                            includeInteraction = TRUE,
                            includeStability = TRUE,
                            distanceMethod = "euclidean",
                            clustMethod = "hclust",
                            #cutMethod = "gap",
                            cutMethod = "dynamic",
                            method = "average",
                            K.max = 10, B = 10, stringsAsFactors = FALSE)

parametersDf <- transform(parametersDf, n0 = n/2)
nSimScenarios <- nrow(parametersDf)
parameterIndex <- 3

simulationParameters <- parametersDf[parameterIndex,, drop = F]

p <- simulationParameters[,"p"];
  n <- simulationParameters[,"n"];
  n0 <- simulationParameters[,"n0"];
  SNR <- simulationParameters[,"SNR"]
  n1 <- n - n0
  cluster_distance <- simulationParameters[,"cluster_distance"]
  Ecluster_distance <- simulationParameters[,"Ecluster_distance"]
  rhoOther <- simulationParameters[,"rhoOther"];
  betaMean <- simulationParameters[,"betaMean"];
  betaE <- simulationParameters[,"betaE"]
  alphaMean <- simulationParameters[,"alphaMean"];
  rho <- simulationParameters[,"rho"];
  nActive <- simulationParameters[,"nActive"];
  includeInteraction <- simulationParameters[,"includeInteraction"]
  includeStability <- simulationParameters[,"includeStability"]
  distanceMethod <- simulationParameters[,"distanceMethod"]
  clustMethod <- simulationParameters[,"clustMethod"]
  cutMethod <- simulationParameters[,"cutMethod"]
  method <- simulationParameters[,"method"]
  K.max <- simulationParameters[,"K.max"]
  B <- simulationParameters[,"B"]
  
  # in this simulation its blocks 3 and 4 that are important
  d0 <- simModule(n = n0, p = p, rho = c(0,0), exposed = FALSE,
                  modProportions = c(0.15,0.15,0.15,0.15,0.15,0.25),
                  minCor = 0.4,
                  maxCor = 1,
                  corPower = 0.3,
                  #propNegativeCor = 0.1,
                  backgroundNoise = 0.2,
                  signed = TRUE,
                  leaveOut = 3:4)
  
  d1 <- simModule(n = n1, p = p, rho = c(rho, rho), exposed = TRUE,
                  modProportions = c(0.15,0.15,0.15,0.15,0.15,0.25),
                  minCor = 0.4,
                  maxCor = 1,
                  corPower = 0.3,
                  #propNegativeCor = 0.1,
                  backgroundNoise = 0.2,
                  signed = TRUE)
  
  # these should be the same. if they arent, its because I removed the red and
  # green modules from the E=0 group
  truemodule0 <- d0$setLabels
  t0 <- table(truemodule0)
  truemodule1 <- d1$setLabels
  t1 <- table(truemodule1)
  #table(truemodule0,truemodule1)
  
  # Convert labels to colors for plotting
  moduleColors <- labels2colors(truemodule1)
  table(moduleColors, truemodule1)
  
  X <- rbind(d0$datExpr, d1$datExpr) %>%
    magrittr::set_colnames(paste0("Gene", 1:p)) %>%
    magrittr::set_rownames(paste0("Subject",1:n))
  
  betaMainEffect <- vector("double", length = p)
  betaMainInteractions <- vector("double", length = p)
  
  # the first nActive/2 in the 3rd block are active
  betaMainEffect[which(truemodule1 %in% 3)[1:(nActive/2)]] <- runif(
    nActive/2, betaMean - 0.1, betaMean + 0.1)
  
  # the first nActive/2 in the 4th block are active
  betaMainEffect[which(truemodule1 %in% 4)[1:(nActive/2)]] <- runif(
    nActive/2, betaMean - 0.1, betaMean + 0.1)
  
  betaMainInteractions[which(betaMainEffect!=0)] <- runif(nActive, alphaMean - 0.1, alphaMean + 0.1)
  
  beta <- c(betaMainEffect,
            betaE,
            betaMainInteractions)
  
  #plot(beta)
  
  result <- generate_data(p = p, n = n, n0 = n0, X = X,
                          beta = beta, include_interaction = includeInteraction,
                          cluster_distance = cluster_distance,
                          EclustAddDistance = Ecluster_distance,
                          signal_to_noise_ratio = SNR,
                          distanceMethod = distanceMethod,
                          clustMethod = clustMethod,
                          cutMethod = cutMethod,
                          method = method,
                          K.max = K.max, B = B)
```



Below I have plotted the heatmaps of several similarity matrices, and have labled the module that they truly belong to, and which of those genes are active. The figures below are based on 


## Heatmaps of Correlations {.tabset}
 

###  $\rho_{All}$

```{r heat-corr-all}
pheatmap(result$corr_train_all,
         show_rownames = F, show_colnames = F,
         clustering_method = "average",
         color = viridis(100),
         annotation_names_row = FALSE,
         annotation_names_col = FALSE,
         drop_levels = FALSE,
         annotation_legend = FALSE)
```


###  $\rho_{E=0}$

```{r heat-corr-e0}
pheatmap(result$corr_train_e0,
         show_rownames = F, show_colnames = F,
         clustering_method = "average",
         color = viridis(100),
         annotation_names_row = FALSE,
         annotation_names_col = FALSE,
         drop_levels = FALSE,
         annotation_legend = FALSE)
```

###  $\rho_{E=1}$

```{r heat-corr-e1}
pheatmap(result$corr_train_e1,
         show_rownames = F, show_colnames = F,
         clustering_method = "average",
         color = viridis(100),
         annotation_names_row = FALSE,
         annotation_names_col = FALSE,
         drop_levels = FALSE,
         annotation_legend = FALSE)
```


###  $S_{pearson} = |\rho_{E=1} - \rho_{E=0}|$

```{r heat-corr-diff}
pheatmap(result$corr_train_diff,
         show_rownames = F, show_colnames = F,
         clustering_method = "average",
         color = viridis(100),
         annotation_names_row = FALSE,
         annotation_names_col = FALSE,
         drop_levels = FALSE,
         annotation_legend = FALSE)
```


### $S = |\rho_{E=0} + \rho_{E=1} - 2 \rho|$

This is one of the Parmigianni 2005 scores, defined as the gap/substitution score. This score finds gene pairs that jointly discriminate the two environments. We choose $\alpha = 2$ because then the score is proportional to $(\rho_1+\rho_2)/2 - \rho$, i.e., the difference between the average of the conditional correlations, and the combined correlations. (In a later paper, the authors suggested 2 instead of the 1.5). By using 2, we now see that the yellow, blue and turquoise model are not highlighted. This score is meant to capture situations such as the on shown in the Artificial Example 1 in the figure below. That is, two genes show a pronounced joint association on the phenotype: if the sum of their expression levels exceeds 3 units, only the blue-triangle phenotype is observed. Neither of the two genes shows a strong association with the phenotype in the univariate marginal distribution.


In their paper they also suggest the difference of class conditional spearman correlations: $|\rho_{E=0} + \rho_{E=1}|$ which captures the Artificial Example 2. If both genes are off (expression values below 1.5 units), or both genes are on (expression value above 1.5 units), we observe the red-circle phenotype. In contrast, if only one of the genes is turned on, the blue-triangle phenotype is
predominant.

```{r cor-scor}
pheatmap(result$corScor,
         show_rownames = F, show_colnames = F,
         clustering_method = "average",
         color = viridis(100),
         annotation_names_row = FALSE,
         annotation_names_col = FALSE,
         drop_levels = FALSE,
         annotation_legend = FALSE)
```


### Fisher's Z Transformation

Let $\rho_{ijk}$ be the correlation between genes $i$ and $j$ in class $k$. Fisher's Z transformation first involves transforming the correlations into z values: $z_{ijk} = 0.5 log | (1 + \rho_{ijk})/(1- \rho_{ijk}) |$. The Z-test statistic is given by $|z_{ij0}-z_{ij1}|/\sqrt{1/(n_0-3) + 1/(n1-3)} \sim \mathcal{N}(0,1)$. This assumes genes $i$ and $j$ follow a bivariate normal distribution. 

```{r fishers-zstat}
pheatmap(result$fisherScore,
         show_rownames = F, show_colnames = F,
         clustering_method = "average",
         color = viridis(100),
         annotation_names_row = FALSE,
         annotation_names_col = FALSE,
         drop_levels = FALSE,
         annotation_legend = FALSE)
```

# Simulation Study 2

I simulate the data in modules (blocks). Within each module, I first generate a random standard normal vector (eigengene) and then calculate the expression levels of all other genes in a module as a function of that eigengene. 

In this simulation setup I have simulated 6 modules with the following proportions and environment dependent correlations :

## Blocks 

1. Turquoise (0.15). Correlated with Blue module regardless of environment
2. Blue (0.15). Correlated with Turquoise module regardless of environment
3. Red (0.15). Correlated with Green module AND within module, only when `E=1`
4. Green (0.15). Correlated with Red module AND within module, only when `E=1`
5. Yellow (0.15). Uncorrelated with any other module regardless of environment
6. Grey (0.25). Uncorrelated within and between modules regardless of environment

## Regression coefficients

I vary the number of active variables. The active genes are split evenly between the Green and Red modules. All active genes have interaction terms as well. I generate the main effects from a $Unif(3.9,4.1)$, the interaction effects from a $Unif(1.9,2.1)$, and $\beta_E = 5$. 

## Error Variance 

Let $Y^* = \beta_E E + \sum_j \beta_j X_j + \alpha_{jE} X_j E$. We generate a continuous response $Y = Y^* + k \cdot \varepsilon$ where the error term $\varepsilon$ is generated from a standard normal distribution, and $k$ is chosen such that the signal-to-noise ratio $\eta = \left(Var(Y^*)/Var(\varepsilon)\right)$ is 1 (e.g. the variance of the response variable $Y$ due to $\varepsilon$ is $1/\eta$ of the variance of $Y$ due to $Y^*$)


We restrict ourselves to only fitting interaction models. The Eclust method is now an addon method in the sense that it also contains the clusters derived from the correlation matrix without considering the environment. We use the first 2 PC's when summarizing a cluster, and fit the model that contains both PCs as well as their interactions with E. 

We vary the:

1. correlation parameter of the first block of genes for the exposed subject (`rho`)
2. the number of variables (`p`)
3. the sample size (`n`)
4. the number of active main effect genes (`nActive`), note that if the main effect is nonzero then it's interaction is automatically also included as associated with the response
5. The matrix used to create environment clusters (`Ecluster_distance`)

We generate original predictors $X_j, j=1, \ldots, p$ from a multivariate normal distribution. The correlation between predictors has a block diagonal structure such that within a block, the correlation between $X_j$ and $X_{j'}$ is $\rho_E$ for $j \neq j'$, where $\rho_E$ depends on exposure status. Let $Y^* = \beta_E E + \sum_j \beta_j X_j + \alpha_{jE} X_j E$. We generate a continuous response $Y = Y^* + k \cdot \varepsilon$ where the error term $\varepsilon$ is generated from a standard normal distribution, and $k$ is chosen such that the signal-to-noise ratio $\left(Var(Y^*)/Var(\varepsilon)\right)$ is 1. Currently, only the differentially correlated block contains the active set.

Recall that the method is the general approach (univariate, penalization, clustering then regression, or environment clustering). The model is what was used to get the coefficient estimates (linear model, lasso, shim which is the strong heredity interaction model). For example, you will notice in the MSE plot, `avg_shim` has two error bars. One corresponds to using average clusters as predictors, and the other corresponds to using average environment clusters as predictors. 

1. `rho`: the correlation for the exposed subjects for the differentially correlated block
2. `rhoOther`: correlation for all other blocks.
3. `betaMean`: the active main effect coefficients are generated from a Uniform(3.9,4.1) distribution
4. `betaE`: coefficient of binary environment variable
5. `alphaMean`: the interaction effect coefficients are generated from a Uniform(1.9,2.1) distribution

```{r results='asis', eval=T}
DT::datatable(parametersDf)
```

Currently we have results for about 50 simulations for each combination of p, rho, N, nActive and Ecluster similarity matrix.


```{r}
params_plots <- expand.grid(n = c(100, 200, 400),
              nActive = c(10, 50, 100),
              eclust_distance = c("diffcorr","fisherScore"))
```
 
 
 
## True Positive Rate vs. Number of non-zero fitted coefficients {.tabset}
 
### Fisher Scoring

```{r true-positive-s-hat-fisher, eval=T}
tp <- DT.long[measure %in% c("TPR","Shat")] %>%
  tidyr::spread(measure, value) %>%
  tidyr::unite(name, summary, model)
tp[,`:=`(method=factor(method, levels = levels),name = factor(name, levels = levels.name, labels = labels.name) )]

# params_plots <- expand.grid(n = c(100, 200, 400),
#               nActive = c(10, 50, 100),
#               eclust_distance = c("fisherScore"))

tpr_shat <- mapply(knitr::knit_expand,
                   file = "tpr_shat_template.Rmd",
                     eclust_distance = c("fisherScore"))
```

`r knitr::knit(text = unlist(tpr_shat))` 

### Difference of Correlations

```{r true-positive-s-hat-diffcorr, eval=T}
tp <- DT.long[measure %in% c("TPR","Shat")] %>%
  tidyr::spread(measure, value) %>%
  tidyr::unite(name, summary, model)
tp[,`:=`(method=factor(method, levels = levels),name = factor(name, levels = levels.name, labels = labels.name) )]

# params_plots <- expand.grid(n = c(100, 200, 400),
#               nActive = c(10, 50, 100),
#               eclust_distance = c("diffcorr"))

# tpr_shat <- mapply(knitr::knit_expand,
#                    file = "tpr_shat_template.Rmd",
#                    n = params_plots$n,
#                    nActive = params_plots$nActive,
#                    eclust_distance = params_plots$eclust_distance)

tpr_shat2 <- mapply(knitr::knit_expand,
                   file = "tpr_shat_template.Rmd",
                     eclust_distance = c("diffcorr"))
```



`r knitr::knit(text = unlist(tpr_shat2))` 


## Test Set MSE Fisher Scoring {.tabset}


```{r mse-fisher, eval=T}

params_plots <- expand.grid(n = c(100, 200, 400),
              nActive = c(10, 50, 100),
              eclust_distance = c("fisherScore"))

mse <- mapply(knitr::knit_expand,
                   file = "mse_template.Rmd",
                   n = params_plots$n,
                   nActive = params_plots$nActive,
                   eclust_distance = params_plots$eclust_distance)


```


`r knitr::knit(text = unlist(mse))` 


## Test Set MSE Difference of Correlations {.tabset}


```{r mse-diffcorr, eval=T}

params_plots <- expand.grid(n = c(100, 200, 400),
              nActive = c(10, 50, 100),
              eclust_distance = c("diffcorr"))

mse2 <- mapply(knitr::knit_expand,
                   file = "mse_template.Rmd",
                   n = params_plots$n,
                   nActive = params_plots$nActive,
                   eclust_distance = params_plots$eclust_distance)


```


`r knitr::knit(text = unlist(mse2))` 

 
 
## Jaccard Index Fisher Scoring {.tabset}


```{r jacc-fisher, eval=T}

params_plots <- expand.grid(n = c(100, 200, 400),
              nActive = c(10, 50, 100),
              eclust_distance = c("fisherScore"))

jacc <- mapply(knitr::knit_expand,
                   file = "jacc_template.Rmd",
                   n = params_plots$n,
                   nActive = params_plots$nActive,
                   eclust_distance = params_plots$eclust_distance)

```


`r knitr::knit(text = unlist(jacc))` 


## Jaccard Index Difference of Correlations {.tabset}


```{r jacc-diffcorr, eval=T}

params_plots <- expand.grid(n = c(100, 200, 400),
              nActive = c(10, 50, 100),
              eclust_distance = c("diffcorr"))

jacc2 <- mapply(knitr::knit_expand,
                   file = "jacc_template.Rmd",
                   n = params_plots$n,
                   nActive = params_plots$nActive,
                   eclust_distance = params_plots$eclust_distance)


```


`r knitr::knit(text = unlist(jacc2))` 
 
 
 
 
 
## Spearman Correlation Fisher Scoring {.tabset}


```{r spearman-fisher, eval=T}

params_plots <- expand.grid(n = c(100, 200, 400),
              nActive = c(10, 50, 100),
              eclust_distance = c("fisherScore"))

spearman <- mapply(knitr::knit_expand,
                   file = "spearman_template.Rmd",
                   n = params_plots$n,
                   nActive = params_plots$nActive,
                   eclust_distance = params_plots$eclust_distance)

```


`r knitr::knit(text = unlist(spearman))` 


## Spearman Difference of Correlations {.tabset}


```{r spearman-diffcorr, eval=T}

params_plots <- expand.grid(n = c(100, 200, 400),
              nActive = c(10, 50, 100),
              eclust_distance = c("diffcorr"))

spearman2 <- mapply(knitr::knit_expand,
                   file = "spearman_template.Rmd",
                   n = params_plots$n,
                   nActive = params_plots$nActive,
                   eclust_distance = params_plots$eclust_distance)


```


`r knitr::knit(text = unlist(spearman2))` 
 
 
 
 
## Pearson Correlation Fisher Scoring {.tabset}


```{r pearson-fisher, eval=T}

params_plots <- expand.grid(n = c(100, 200, 400),
              nActive = c(10, 50, 100),
              eclust_distance = c("fisherScore"))

pearson <- mapply(knitr::knit_expand,
                   file = "pearson_template.Rmd",
                   n = params_plots$n,
                   nActive = params_plots$nActive,
                   eclust_distance = params_plots$eclust_distance)

```


`r knitr::knit(text = unlist(pearson))` 


## Pearson Correlation Difference of Correlations {.tabset}


```{r pearson-diffcorr, eval=T}

params_plots <- expand.grid(n = c(100, 200, 400),
              nActive = c(10, 50, 100),
              eclust_distance = c("diffcorr"))

pearson2 <- mapply(knitr::knit_expand,
                   file = "pearson_template.Rmd",
                   n = params_plots$n,
                   nActive = params_plots$nActive,
                   eclust_distance = params_plots$eclust_distance)


```


`r knitr::knit(text = unlist(pearson2))` 




